# 멀티 포맷 기획서 기반 코드 리뷰 시스템 설계

## 1. 시스템 개요

![[Code Review Agent Pipeline-2026-02-02-082624.png|512]]

이 시스템의 목적은 **파편화된 기획서 포맷에 상관없이 기획 의도를 정밀하게 추출하고, 이를 코드의 실제 실행 경로와 대조함으로써 기획-구현 간의 간극을 제거한 고품질 코드 리뷰 피드백을 산출하는 것**입니다.

실무 환경에서 기획서는 Excel, PPT, Notion, Confluence 등 다양한 형태로 존재하며, 각 포맷은 고유한 표현 방식과 구조적 제약을 가집니다. 이로 인해 동일한 기획 의도라도 문서 형식에 따라 표의 위치, 시각적 레이아웃, 혹은 서술식 텍스트 등으로 다르게 표현됩니다. 이러한 **표현의 다양성**은 코드 리뷰 단계에서 리뷰어의 주관적 해석에 의존하게 만들며, 결과적으로 기획 의도가 코드에 암묵적으로 반영되거나 누락되는 문제를 야기합니다.

본 시스템은 이러한 해석의 불일치를 근본적으로 해결하기 위해 다음과 같은 단계로 가치를 창출합니다.

1. 신뢰할 수 있는 단일 출처 형성: 모든 기획서를 포맷에 무관하게 정형화된 데이터 모델로 변환하여 해석의 모호함을 제거합니다.
    
2. 실행 경로 기반 검증: 정형화된 기획 데이터와 실제 코드의 실행 경로(Execution Path)를 직접 대조하여, 비즈니스 로직의 누락이나 제약 조건의 위반을 기계적 정밀도로 탐지합니다.
    
3. 최종 가치 제공 (Actionable Feedback): 검증 결과를 바탕으로 개발자가 즉시 수정에 반영할 수 있도록 **기획적 근거와 코드 수준의 개선안이 결합된 종합 리뷰 리포트를 생성**합니다.


결과적으로 본 시스템은 기획서가 단순한 문서에 머물지 않고 **코드의 정합성을 보장하는 살아있는 검증 기준**으로 기능하게 함으로써, 개발 프로세스 전체의 신뢰도를 높이는 것을 최종 목표로 합니다.

## 2. 전체 아키텍처 개요

시스템은 크게 다음 두 단계로 구성됩니다.

1. **Multi-Modal Ingestion & Normalization** : 다양한 기획서 포맷을 정형화된 문서로 변환

2. **Code Review Agent** : 정제된 기획서와 실제 코드를 비교하여 로직 적합성 검증

각 단계는 LangGraph 기반의 State Graph로 구성되며, 복잡한 분기와 retry 로직을 제어할 수 있도록 설계합니다.

## 3. 라우팅 레이어 (Supervisor)

라우팅 레이어는 시스템의 진입점으로서, 입력된 소스가 어떤 처리 파이프라인으로 전달되어야 하는지 결정합니다.

모든 팀이 공용으로 사용하는 시스템이므로, 초기 단계에서 **보안 및 접근 제어**가 우선적으로 수행됩니다.

### 3.1 접근 제어 및 보안

- 사용자는 UI를 통해 기획서 파일 또는 Git Repository 주소, 소스코드등 을 입력/첨부합니다.
- 각 팀의 데이터는 논리적으로 격리되며, AWS IAM Role 기반 접근 제어, 팀 단위 Resource Boundary를 통해 권한을 제한합니다.
- Supervisor는 인증이 완료된 리소스만 이후 단계로 전달합니다.

### 3.2 라우팅 판단 기준
Supervisor는 다음과 같은 features를 기반으로 SubGraph를 선택합니다.

- 파일 MIME type 및 헤더(Magic Number)

- URL 도메인 및 패턴

- 입력 메타데이터 (확장자, source type 등)

## 4. LangGraph 기반 전처리 에이전트 설계

![[Code Review Agent Pipeline-2026-02-02-082728.png]]
### 4.1 Agent 설계 원칙

하나의 거대한 에이전트가 모든 포맷과 도구를 처리하는 구조는 제어 불가능한 추론을 유발할 수 있습니다. 따라서 여기에서는 **계층형 멀티 에이전트 구조**를 채택합니다.

- Supervisor Graph
  - 어떤 Sub-graph로 전달할지만 결정

- Format-specific Sub-graph
  - 각 포맷은 독립적인 State를 가지며, 내부에서만 재시도 및 오류 복구 수행

이 구조를 통해 특정 포맷 처리 중 발생한 오류가 전체 파이프라인으로 전파되는 것을 방지합니다.

## 5. Notion / Confluence 처리

Notion 과 Confluence 문서는 단일 텍스트가 아니라
- `텍스트 블록`
- `이미지`
- `테이블`
- `임베드 콘텐츠`

등이 혼합된 **Block 기반 문서 구조** 입니다.

단순 텍스트 추출만으로는 기획 의도를 온전히 추출할 수 없습니다.
이것을 처리하기 위한 전략으로 Sub-graph는 **재귀적 파이프라인(Recursive Pipeline)** 으로 구성됩니다.

1. Block Fetcher
	- API를 통해 블록 트리를 재귀적으로 수집
	
2. Media Router (Conditional Edge)
	- 이미지 / 차트 블록 감지 시
	
3. VLM Description Node
	- 이 이미지를 VLM에 전달하여 "이 이미지가 표현하는 흐름 또는 로직"을 텍스트로 변환
	
4. Structure Parser
	- H1, H2, Bullet, Table 구조를 Markdodwn 으로 보존

이 Sub-graph의 산출물을 다음과 같이 예상됩니다.

- Markdown 기반
- 모든 이미지가 description 텍스트로 치환
- 문서의 계층 구조가 명확히 표현

이렇게 API 기반 블록 수집 -> Media Router -> VLM 설명 생성 -> Markdown 구조화 단계를 통해 비정형 블록 데이터를 정형화된 문서로 변환합니다.

## 6. Excel / PPT 처리

Excel과 PPT는 **데이터의 위치**와 **시각적 요소**가 비즈니스 로직을 결정하는 핵심 요소입니다. 이를 위해 단순 텍스트 추출이 아닌 다단계 파싱 전략을 사용합니다.

### 6.1 Excel  : 구조적 파싱
Excel은 단순 표가 아니라 계층 구조를 가진 데이터베이스로 취급합니다.

1. `OpenPyXL` 등을 이용해 셀의 값 뿐만 아니라 **병합 상태**, **배경색**, **폰트 굵기** 등의 메타데이터 정보를 함께 추출합니다.

2. 병합된 셀을 상위 노드로 설정하여 트리 구조를 형성합니다.

3. 색상과 스타일 패턴을 분석해 헤더 영역과 데이터 영역을 구분합니다.

4. 추출된 공간 정보를 기반으로 LLM이 JSON Schema 형태로 정규화합니다.

### 6.2 PPT : VLM 기반 로직
PPT는 텍스트와 레이아웃이 결합된 visual 문서입니다. 여기서 **OCR과 VLM의 추론 능력을 이용**하여 처리합니다.

1. 슬라이드 전체를 고해상도 이미지로 입력받아, VLM이 텍스트 추출과 이미지 분석을 동시에 수행합니다.

2. 화면 설계도 내의 버튼, 입력창, 데이터 표시 영역 간의 상호작용을 분석합니다.

3. (Optional OCR) 아주 작은 텍스트나 복잡한 수식 등 VLM이 놓치기 쉬운 부분에 대해서만 부분적으로 OCR을 병행하여 정밀도를 보완합니다.

4. 슬라이드별 분석 결과를 종합하여, 어떤 화면에서 어떤 데이터가 어떤 조건에 의해 처리되는지를 기술하는 Markdown 기반 문서를 생성합니다.

## 7. Code Review Agent 설계

![[Code Review Agent Pipeline-2026-02-02-082914.png|512]]

이 시스템에서 코드 리뷰 에이전트의 역할을 단순히 코드가 기획서와 일치하는지를 판별하는 것이 아니라

**정형화된 기획서를 기준으로 실제 코드 구현이 해당 제약을 충족하는지를 검증하고, 그 결과를 개발자가 활용할 수 있는 형태의 피드백으로 제공하는 것**입니다.

즉, 코드 리뷰 에이전트는 이 코드가 어느 기획서의 어느 부분에서 어떤 이유로 충족되지 않았는지를 설명합니다.

### 7.1 Code Review Agent의 기본 철학

코드 리뷰 에이전트는 다음 두 가지 질문에 답하는 것을 목표로 합니다.

1. 이 코드베이스안에 기획서가 요구하는 동작을 만족하는 실행 코드가 존재하는가

2. 만약 존재하지 않는다면 어디에서, 어떤 제약이, 어떤 이유로 충족되지 않았는가

3. 해당 코드베이스의 구조와 스타일을 유지한 채, 기획서의 제약을 충족시키기 위해 어떤 수정이 가능한가

이를 위해 에이전트는 코드의 실행 흐름을 따라가며 검증 가능한 증거를 수집합니다.
검증 과정에서 에이전트는 단순히 문제를 지적하는 데서 멈추지 않고, 현재 코드의 설계 패턴, 조건 검사 위치 등을 분석하여 **기존 코드베이스의 스타일과 구조를 유지하면서 기획서 제약을 실현할 수 있는 실행 코드 수준의 개선 제안을 생성**합니다. 

### 7.2 구조화된 데이터 활용 방식

코드 리뷰 에이전트는 정형화된 데이터를 RAG를 위한 검색 쿼리로 사용하지 않습니다. 대신, 다음과 같은 정보를 포함한 **검증 기준 문서로 활용**됩니다.

1. 기능이 동작해야 하는 조건

2. 상태 변화 및 후속 처리

3. 예외 상황 및 제한 상황

4. 입력과 출력 간의 관계

에이전트는 이 기준을 바탕으로 "코드가 무엇을 하고 있는가"를 추측하지 않고 "코드의 실행 경로가 이 기준을 만족하는가"를 확인합니다.

### 7.3 코드베이스 탐색 전략 (Agentic Navigation)

코드 리뷰 에이전트는 전체 소스코드를 한 번에 분석하지 않습니다. 이는 단순한 토큰 제한 문제를 넘어, 실행 흐름 기반의 정밀 검증을 위해 **사람이 코드를 리뷰하는 방식과 유사한 점진적 탐색 전략**을 취하기 위함입니다. 모든 코드를 동시에 보는 접근은 오히려 판단의 노이즈를 발생시킬 수 있으므로, 에이전트는 다음과 같은 단계적 프로세스를 통해 코드베이스를 이해합니다.

- 설계 의도 파악: 탐색 초기에는 기획서와의 비교를 지양하고, 프로젝트의 디렉토리 구성과 파일 배치를 먼저 분석합니다. 이를 통해 컨트롤러, 서비스, 도메인 계층의 분리 방식과 프레임워크 특성에 따른 책임 분배 구조를 파악하여 "기능이 구성된 방식"을 이해합니다.
    
- 실행 진입점 식별: 구조 파악 후에는 외부 입력이나 이벤트가 로직으로 유입되는 지점(HTTP 엔드포인트, 백그라운드 잡, 이벤트 핸들러 등)을 찾아냅니다. 이 진입점은 기획서 요구사항이 실제 구현으로 전이되는 기준점이 됩니다.
    
- 의존성 기반 경로 추적: 식별된 진입점부터 함수 호출, 클래스 간 위임, 의존성 주입 관계를 따라가며 분석 범위를 확장합니다. 단순 키워드 매칭이 아닌 실제 참조 관계를 기준으로 탐색하며, 기획서와 무관한 경로는 분석 대상에서 제외하여 효율성을 극대화합니다.

### 7.4 제약 기반 검증

실행 경로가 확보되면, 에이전트는 해당 경로가 정형화된 기획 데이터에 정의된 제약 조건을 충족하는지 검증합니다. 이때 검증의 핵심은 단순히 유사한 기능의 존재 여부가 아니라, **명시된 조건과 상태 변화가 코드상에서 명확하게 보장되고 있는가**를 확인하는 것입니다.

에이전트는 단순히 if 문의 존재를 확인하는 수준을 넘어, 다음의 **실행 맥락**을 종합적으로 검증합니다.

- 검증 계층의 적절성: 제약 조건 검사가 비즈니스 로직에 적합한 계층(Service 또는 Domain)에서 수행되는지 확인
    
- 예외 전파 매커니즘: 조건을 만족하지 않을 경우 예외 상황이 호출자에게 적절한 규격으로 전달되는지 분석
    
- 책임 할당: 상태 변경이 해당 데이터를 관리하는 적절한 책임을 가진 객체에서 이루어지는지 검토
    

이러한 검증 결과는 **충족(Pass), 부분 충족(Partial), 미충족(Fail)**으로 구분되어 이후 구체적인 피드백 생성의 기초 데이터로 활용됩니다.

### 7.5 실행 코드 수준의 피드백 생성

검증 결과 결함이 발견된 경우, 에이전트는 단순한 문제 나열을 넘어 **현실적인 수정 방향**을 제시합니다. 에이전트는 현재 코드베이스가 따르고 있는 설계 패턴과 유사한 기능이 구현된 기존 코드의 스타일을 분석하여, 개발자가 즉시 적용할 수 있는 수준의 가이드를 제공합니다.

에이전트가 생성하는 피드백의 특징은 다음과 같습니다.

- 맥락 유지: 전면적인 리팩토링이 아닌, 기존 코드 흐름에 자연스럽게 삽입될 수 있는 국소적 수정을 제안합니다.
    
- 사례 기반 제안: 누락된 조건 검사가 있다면 프로젝트 내 다른 위치에서 사용 중인 유사 검증 로직을 참조하여 제안합니다.
    
- 실행 가능성: 단순한 "판정"이 아니라, 코드 스타일을 유지하면서 보완 가능한 구체적인 수정 지점과 방식(Code-level suggestion)을 포함합니다.
    

### 7.6 탐색 범위 제어 및 종료 조건

에이전트의 자율적 탐색(Agentic Navigation)은 리소스 낭비와 무한 루프를 방지하기 위해 명시적인 제어 메커니즘을 가집니다. 시스템은 다음과 같은 종료 조건을 기준으로 분석을 마무리합니다.

1. 최대 탐색 깊이 도달 진입점으로부터 정의된 일정 단계 이상의 호출 스택 탐색 시 제한
    
2. 분석 대상 파일 수 제한: 단일 요구사항 검증을 위해 탐색하는 총 파일 수의 임계치 설정
    
3. 경로 소진: 추가적인 실행 경로 및 의존성 참조가 더 이상 발견되지 않는 시점
    
4. 검증 완료: 기획서에 명시된 모든 제약 조건 노드에 대한 판정이 완료된 경우

### 7.7 에이전트 구동 환경 및 보조 인프라

에이전트가 복잡한 코드베이스를 탐색하고 장시간 추론을 유지하기 위해 다음과 같은 보조 시스템을 결합합니다.

- Redis
    - 상태 보존: LangGraph의 세션별 State를 저장하는 Checkpointer로 활용하여, 대규모 코드 분석 중 예기치 못한 중단이 발생해도 마지막 지점부터 재개가 가능하도록 설계합니다.
        
    - 공유 메모리: 여러 에이전트 노드 간에 탐색 완료된 파일 목록이나 공통 라이브러리 해석 결과를 공유하여 중복 연산을 방지합니다.
        
- Qdrant
    - 초기 진입점 필터링: 전체 레포지토리의 소스코드를 청크(Chunk) 단위로 임베딩하여 저장합니다. Agentic Navigation을 시작하기 전, 기획서의 키워드와 가장 연관성이 높은 코드 위치를 신속하게 필터링하는 용도로 사용합니다.
        
    - Payload 기반 필터링: 파일 확장자, 디렉토리 경로, 언어 등 메타데이터 필터링 기능을 활용하여 에이전트가 분석해야 할 코드의 범위를 효율적으로 좁힙니다.


## 8. 인프라 아키텍처 및 공용 서비스 설계

이 시스템은 사내 모든 게임팀이 사용하는 공용 서비스이므로, **확장성, 비용 효율성, 비동기 처리**를 최우선으로 하여 AWS 기반으로 설계합니다.

### 8.1 비동기 이벤트 기반 처리

LLM및 VLM을 활용한 분석은 처리 시간이 길기 때문에, 사용자 UI의 타임아웃을 방지하고 시스템 안정성을 확보하기 위해 비동기 구조를 채택합니다.

- Request Handling: 사용자가 UI 혹은 Git Webhook을 통해 리뷰를 요청하면 API Gateway와 Lambda가 요청을 수신하고 SQS(Message Queue)에 작업 메시지를 쌓습니다.
    
- Worker Nodes: AWS ECS Fargate 기반의 에이전트 러너가 SQS에서 메시지를 소비하여 LangGraph 파이프라인을 실행합니다. Fargate를 사용함으로써 운영 인력 없이도 트래픽에 따른 오토스케일링이 가능합니다.
    
- Storage: 기획서 원본 및 전처리된 정형 데이터는 S3에 저장하며, 리뷰 이력 및 팀별 설정 정보는 DynamoDB에 관리합니다.

### 8.2 사내 시스템 연계 및 보안

- 인증 및 권한 (SSO/IAM): 사내 SSO와 연동된 AWS Cognito를 통해 사용자 인증을 수행합니다. 각 팀의 데이터는 S3 내의 팀 전용 Prefix와 IAM Role의 Condition 설정을 통해 논리적으로 엄격히 격리됩니다.
    
- Git 통합 워크플로우: 개발팀이 수동으로 도구를 실행할 필요가 없도록 GitLab/GitHub Webhook과 연동합니다. Pull Request(PR) 생성 시 자동으로 리뷰 에이전트가 동작하며, 결과는 PR의 Code Comment 형식으로 즉시 제공됩니다.

## 9. 핵심 기술 선택 사유
이 설계에서 채택한 주요 기술들의 선택 의도는 다음과 같습니다.

| 기술 요소                           | 선택 사유                                                                                                                                       |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| **LangGraph**                   | 포맷별 복잡한 분기 및 재시도 로직을 **상태 기반(Stateful)**으로 제어합니다. 특히, 기획서 형식이 추가될 때마다 그에 맞는 **전용 에이전트와 도구(Tool)를 Sub-graph 형태로 유기적으로 추가**할 수 있는 확장성이 핵심입니다. |
| **VLM (Vision-Language Model)** | PPT의 시각적 위계와 도식화된 로직(순서도, UI 레이아웃)은 일반적인 OCR 단독으로는 추출이 불가능하며, **공간적 맥락을 이해**하는 VLM이 필수적입니다.                                                 |
| **Agentic Navigation**          | 대규모 코드베이스 전체를 임베딩하는 방식(RAG)은 비용이 높고 환각(Hallucination) 위험이 큽니다. 실제 개발자의 사고 과정을 모사한 **단계적 탐색**이 더 높은 정확도를 보장합니다.                              |
| **Redis**                       | LangGraph의 **분산 상태 관리와 체크포인트(Checkpointer)** 기능을 구현하기 위한 최적의 저장소입니다. 장시간 소요되는 에이전트의 추론 과정을 안정적으로 지속시키고 세션 간 메모리를 공유하기 위해 선택했습니다.            |
| **Qdrant**                      | 코드베이스의 대규모 인덱싱에 최적화된 성능과 **강력한 페이로드 필터링** 기능을 제공합니다. 단순 벡터 유사도 검색을 넘어, 특정 디렉토리나 타입으로 한정된 하이브리드 검색을 통해 에이전트의 초기 탐색 효율을 극대화합니다.               |

