- [[#자료 정렬의 개념|자료 정렬의 개념]]
- [[#정렬 알고리즘의 분류|정렬 알고리즘의 분류]]
	- [[#정렬 알고리즘의 분류#비교 기반 정렬 (Comparison-based Sorting)|비교 기반 정렬 (Comparison-based Sorting)]]
		- [[#비교 기반 정렬 (Comparison-based Sorting)#버블 정렬(Bubble Sort)|버블 정렬(Bubble Sort)]]
		- [[#비교 기반 정렬 (Comparison-based Sorting)#퀵 정렬|퀵 정렬]]
		- [[#비교 기반 정렬 (Comparison-based Sorting)#병합 정렬|병합 정렬]]
	- [[#정렬 알고리즘의 분류#비비교 기반 정렬|비비교 기반 정렬]]
		- [[#비비교 기반 정렬#계수 정렬(Counting Sort)|계수 정렬(Counting Sort)]]
		- [[#비비교 기반 정렬#기수 정렬 (Redix Sort)|기수 정렬 (Redix Sort)]]


## 자료 정렬의 개념

자료 정렬은 **데이터를 특정 기준에 따라 순서대로 배치하는 과정**을 의미합니다. 정렬은 데이터의 효율적인 검색, 분석, 가공을 가능하게 하며, [[Computer Science]] 과 데이터 처리에서 핵심적인 역할을 합니다.

예시로 숫자 리스트

```
[5, 2, 8, 1]
```

을 오름차순으로 정렬하면

```
[1, 2, 5, 8]
```

이 됩니다.

## 정렬 알고리즘의 분류

정렬 알고리즘은 데이터를 특정 순서로 배열하는 방법으로, 비교 기반, 비비교 기반, 안정성, 제자리 정렬 여부로 나뉩니다. 아래에서 각 알고리즘의 동작 과정을 단계별로 설명합니다.

### 비교 기반 정렬 (Comparison-based Sorting)

#### 버블 정렬(Bubble Sort)

![[Pasted image 20250522151421.png]]


인접한 두 요소를 비교하여 순서가 맞지 않으면 교환합니다. 이 과정을 반복해 가장 큰(또는 작은) 요소가 배열의 끝으로 "버블"처럼 올라갑니다.

예로 `[5, 2, 8, 1]` 을 오름차순으로 정렬한다면

첫 번째 반복

```
[5, 2, 8, 1]

[2, 5, 8, 1]

[2, 5, 8, 1]

[2, 5, 1, 8]
```

두 번째 반복

```
[2, 5, 1, 8]

[2, 1, 5, 8]

[2, 1, 5, 8]
```

세 번째 반복

```
[1, 2, 5, 8]
```

#### 퀵 정렬

![[Pasted image 20250522151839.png]]

퀵 정렬은 배열을 정렬하는 방법 중 하나로, 비교 기반 정렬에 속합니다. 이 알고리즘은 <font color="#ffff00">피벗</font> 이라는 기준 요소를 선택해서 배열을 피벗보다 작은 값과 큰 값으로 나누고, 나눠진 부분 배열을 재귀적으로 정렬하는 방식으로 작동합니다.

퀵 정렬이 어떻게 동작하는지 예시를 통해 살펴보겠습니다.

배열 `[5, 2, 8, 1, 9, 3]` 을 오름차순으로 정렬한다고 가정하고, 피벗으로 첫 번째 요소를 선택하겠습니다.

먼저 피벗 5를 기준으로 5보다 작은 값(2,1,3)을 왼쪽에, 큰 값(8,9)을 오른쪽에 배치합니다. 왼쪽 포인터는 5보다 큰 값을 찾고, 오른쪽 포인터는 5보다 작은 값을 찾아 교환합니다. 이 과정을 포인터가 교차할 때까지 반복하면 5는 최종 위치에 놓입니다. 이후 왼쪽과 오른쪽 부분 배열을 재귀적으로 정렬합니다.

```
원본 배열: [5, 2, 8, 1, 9, 3]
피벗 선택: 5
분할 후: [3, 2, 1, 5, 8, 9]
왼쪽 부분 정렬: [3, 2, 1] → [1, 2, 3]
오른쪽 부분: [8, 9] (이미 정렬됨)
최종 결과: [1, 2, 3, 5, 8, 9]
```

#### 병합 정렬

![[Pasted image 20250522152225.png|512]]

병합 정렬은 비교 기반 정렬로, **분할 정복 방식을 사용**합니다. 배열을 계속 반으로 나누어 최소 단위(1개 요소)까지 쪼갠 뒤, 정렬하면서 병합합니다. 병합 과정에서는 두 정렬된 부분 배열을 비교하여 새로운 배열에 값을 순서대로 넣습니다. 이 방식은 안정적이로 일관된 성능을 보장하지만, 병합 시 추가 메모리가 필요합니다.

예를 들어, 배열 `[5,2,8,1]` 을 오름차순으로 정렬한다고 해보겠습니다.

먼저 배열을 반으로 나눠 `[5,2]` 와 `[8,1]` 로 만듭니다. 다시 각각을 `[5]`, `[2]`, 와 `[8]`, `[1]` 로 나눕니다. 이제 이 최소 단위들을 병합하면서 정렬합니다.

```
원본 배열: [5, 2, 8, 1]
분할: [5, 2]와 [8, 1]
다시 분할: [5], [2]와 [8], [1]
병합: [5], [2] → [2, 5]
병합: [8], [1] → [1, 8]
최종 병합: [2, 5]와 [1, 8] → [1, 2, 5, 8]
```

### 비비교 기반 정렬

#### 계수 정렬(Counting Sort)

계수 정렬은 비비교 기반 정렬로, 데이터 값의 범위가 제한적일 때 매우 빠릅니다. 데이터 값의 빈도를 세고 이를 이용해 정렬된 결과를 만듭니다. 주로 저수 데이터가 사용됩니다.

예를 들어, 배열 `[3,1,4,1,5]` 를 정렬하고, 값범위가 0에서 5라고 가정하겠습니다. 먼저 각 값의 빈도를 계산합니다. 그다음 누적 빈도를 계산해 각 값이 최종 배열에서 어디에 위치할지 결정합니다. 원래 배열을 역순으로 처리하며 값을 배치합니다.

```
원본 배열: [3, 1, 4, 1, 5]
빈도 배열 (0~5): [0, 2, 0, 1, 1, 1] (1이 2번, 3이 1번, 4가 1번, 5가 1번)
누적 빈도: [0, 2, 2, 3, 4, 5]
배치 (역순):
  5 → 위치 5 → [_, _, _, _, 5]
  1 → 위치 2 → [_, 1, _, _, 5]
  4 → 위치 4 → [_, 1, _, 4, 5]
  1 → 위치 1 → [1, 1, _, 4, 5]
  3 → 위치 3 → [1, 1, 3, 4, 5]
최종 결과: [1, 1, 3, 4, 5]
```

#### 기수 정렬 (Redix Sort)

![[Pasted image 20250522162243.png]]

기수 정렬은 비비교 기반 정렬로, 데이터의 자릿수를 기준으로 낮은 자릿수부터 정렬합니다. 각 자릿수 정렬에는 보통 계수 정렬을 사용합니다. 보통 **정수나 고정 길이 문자열에 사용**됩니다. 

예를 들어, 배열 `[170, 45, 75, 90]` 을 정렬한다고 해보겠습니다. 먼저 1의 자리부터 정렬하고, 다음으로 10의 자리, 100의 자리 순으로 진행합니다.

```
원본 배열: [170, 45, 75, 90]
1의 자리 정렬: 170(0), 90(0), 45(5), 75(5) → [170, 90, 45, 75]
10의 자리 정렬: 170(7), 90(9), 45(4), 75(7) → [45, 170, 75, 90]
100의 자리 정렬: 45(0), 75(0), 90(0), 170(1) → [45, 75, 90, 170]
최종 결과: [45, 75, 90, 170]
```

